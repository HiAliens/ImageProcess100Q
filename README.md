# ImageProcess100Q
100 questions for image processing  
Orign URL:https://github.com/gzr2017/ImageProcessing100Wen  

这是我对上面GitHub给出教程的学习，我对代码添加了一些注释，文档中有些符号是我的命名习惯，与原文不同，下面的涉及到了opencv的使用，opencv如和使用，参考我的这个github仓库：  
https://github.com/HiAliens/OpencvExample 两者放在一起看，会获得意想不到的体验---amazing。

## Q1  
三通道图像为彩色，单通道图像为灰色（又称二值图像），图像数据（整型类型）以三维数组的形式存在，可以使用img.shape获取数组的形状（H，W，C）。opencv读取图像以BGR通道顺序读图片，实现通道转变只需对利用python数组的赋值操作。

## Q2
图片灰度化，即将三通道图像变为单通道图像，需要用到转换公式：  
  out = 0.2126 * r + 0.7152 * g + 0.0722 * b
可以看到公式中设计道了浮点数的运算，所以在读取图片时候直接以浮点数类型进行读取，运算完成后再转换为整型。

## Q3
图片二值化，二值化是用0或1去替代数组中的所有值，往往根据一个给定的阈值（threshold）来确定是0还是1.  
首先将图片转化为灰度图，之后以127作为阈值，将数组中数值比较大小后赋值成0或1.

## Q4
大津二值化，是通过算法自动计算出图片的二值化阈值，计算设计到图片像素的均值、方差、类间方差、类内方差，最佳阈值是使得类间方差最大的值。  
说明：

* 使用t代表阈值，小于t的值记为0，大于t的值记为1  
* 使用r0、r1代表上述两类像素分别占总像素个数的比值，总像素为 H * W  
* 使用s0、s1代表每一类的方差  
* 使用m0、m1代表每一类的均值

算法思路：  
t从0到255遍历每一个值，利用每一个ti（0<=i<255）去将数组中分类两类，之后计算这两类的类间方差，将最大的类间方差对应的t记录下来，这就是最后阈值t。类间方差计算公式为：  

    sigam = r0 * r1 * (m0 - m1) ** 2.
补充：

    类内方差 = r0  * s0 + r1 * s1
## Q5
将图形转换到HSV空间，色调（H），饱和度（S），明度（V）。    

色相：将颜色使用0到360度表示，就是平常所说的颜色名称，如红色、蓝色。色相与数值按下表对应： 

> 红|黄|绿|青色|蓝色|品红|红
> -|--|---|--|----|---|--
> 0|60|120|180|240|300|360

> 饱和度：是指色彩的纯度，饱和度越低则颜色越黯淡( 0<= S < 1)；   
> 明度：即颜色的明暗程度。数值越高越接近白色，数值越低越接近黑色 ( 0 <= V < 1)；    
    
转换方法如下：  

1. 将图像像素归一化到【0，1】之间，方法是每个像素除以255.  
2. 需要一下数据计算：
>   Max = max(R,G,B)
    Min = min(R,G,B)
    H =  { 0                            (if Min=Max)
        60 x (G-R) / (Max-Min) + 60  (if Min=B)
        60 x (B-G) / (Max-Min) + 180 (if Min=R)
        60 x (R-B) / (Max-Min) + 300 (if Min=G)         
    V = Max
    S = Max - Min
3. 转换方式：   
```
      C = S
      H' = H / 60
      X = C (1 - |H' mod 2 - 1|)
      (R,G,B) = (V - C) (1,1,1) + { (0, 0, 0)  (if H is undefined)
                                  (C, X, 0)  (if 0 <= H' < 1)
                                  (X, C, 0)  (if 1 <= H' < 2)
                                  (0, C, X)  (if 2 <= H' < 3)
                                  (0, X, C)  (if 3 <= H' < 4)
                                  (X, 0, C)  (if 4 <= H' < 5)
                                  (C, 0, X)  (if 5 <= H' < 6)
```
## Q6 
将图片减色，公式如下：
>val = {  32  (  0 <= val <  64)  
         96  ( 64 <= val < 128)  
        160  (128 <= val < 192)  
        224  (192 <= val < 256)  
        
## Q7
平均池化，池化操作会将图像变模糊，形成马赛克那种效果，实现途径是利用一个固定大小窗口在原图像上滑动，窗口覆盖区域内所有值为这个区域内的平均值。
实现时每次在计算窗口大小的数据平均之后将这个均值赋予给窗口内每一个像素点就行。

## Q8
最大池化，这次窗口内的最大值。

## Q9
高斯滤波，滤波操作可以去除图像内的噪声点。实质是平滑操作，将一个像素点依据周围像素重新计算。高斯滤波核计算公式：
~~~
权值 g(x,y,s) = 1/ (s*sqrt(2 * pi)) * exp( - (x^2 + y^2) / (2*s^2))
标准差 s = 1.3 的 8 近邻 高斯滤波器如下：
            1 2 1
K =  1/16 [ 2 4 2 ]
            1 2 1
~~~
实现思想是：先对原始图像img进行边补零操作（图像的长宽可能不是滤波器大小的整数倍）；之后是卷积核的实现，其实现是以卷积核中心为坐标原点，接着以中心形成
8邻接的方阵（3\*3），依此来根据公式计算，公式如下：  
 
    g(x,y,s) = 1/ (s*sqrt(2 * pi)) * exp( - (x^2 + y^2) / (2*s^2))
卷积核生成后，在补零后的图象上进行卷积，操作类似于Q7、Q8的过程。
## Q10
中值滤波，这里的中值是每个核覆盖像素中的中位数。

## Q11
均值滤波，取每个核覆盖下所有像素的均值。

## Q12
Motion滤波，滤波核为：
~~~
 [[1., 0., 0.],
 [0., 1., 0.],
 [0., 0., 1.]]
 ~~~
 滤波核与覆盖像素对应相乘后再求和。
 
 ## Q13
 最大值-最小值滤波
 在灰度空间下，求出滤波核覆盖下像素最大值与最小值的差
 
 ## Q14
 微分滤波器，分为垂直和水平两个方向，滤波核为：
 ~~~
 水平：
 【【0.， 0。， 0.】，
   【-1.， 1.，0.】，
   【0.， 0.， 0.】】
  垂直：
  【【0.， -1.， 0.】，
    【0.， 1.， 0.】
    【0.， 0.， 0.】】
 ~~~
滤波核下对应像素值相乘后求和, 之后对输出图像numpy数组中的值进行截断处理，截断区间为（0，255）。

## Q15
Sobel滤波器，分为垂直和水平两个方向，滤波核为：
~~~
水平：
【【1.， 0.， -1】，
  【2.， 0.， -2】，
  【1.， 0.， -1】】
垂直：
【【1.， 2.， 1.】，
  【0.， 0.， 0.】，
  【-1.，-2.， -1.】】
~~~
滤波核下对应像素值相乘后求和, 之后对输出图像numpy数组中的值进行截断处理，截断区间为（0，255）。

## Q16
Prewitt滤波器：
prewitt滤波器，分为垂直和水平两个方向，滤波核为：
~~~
水平：
【【-1.， 0.， 1.】，
  【-1，  0.， 1.】，
  【-1.， 0.， 1.】】
垂直：
【【-1.， -1.， -1.】，
  【0.，   0.，  0.】,
  【-1.， -1.， -1.】】
~~~
滤波核下对应像素值相乘后求和, 之后对输出图像numpy数组中的值进行截断处理，截断区间为（0，255）。

## Q17
laplacian滤波器， 滤波核为：
~~~
[[0., 1., 0.],
[1., -4., 1.], 
[0., 1., 0.]]
~~~
滤波核下对应像素值相乘后求和, 之后对输出图像numpy数组中的值进行截断处理，截断区间为（0，255）。

## Q18
Emboss滤波器，滤波核为：
~~~
[[-2., -1., 0.], 
[-1., 1., 1.], 
[0., 1., 2.]]
~~~
滤波核下对应像素值相乘后求和, 之后对输出图像numpy数组中的值进行截断处理，截断区间为（0，255）。

## Q19
Log滤波器，滤波核构造与高斯滤波核一样，以滤波为中心为原点，计算周围8邻域值得大小。
 【(x ** 2 + y ** 2 - sigma ** 2) * np.exp( -(x ** 2 + y ** 2) / (2 * (sigma ** 2))) / (2 * np.pi * (sigma ** 6))】 / 分子和。    
 滤波核下对应像素值相乘后求和, 之后对输出图像numpy数组中的值进行截断处理，截断区间为（0，255）。
 
 ## Q20
 利用matplotlib绘制图片得直方图
